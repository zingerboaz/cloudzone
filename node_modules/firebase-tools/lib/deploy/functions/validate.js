"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkForInvalidChangeOfTrigger = exports.packageJsonIsValid = exports.functionIdsAreValid = exports.functionsDirectoryExists = void 0;
const clc = require("cli-color");
const path = require("path");
const error_1 = require("../../error");
const logger_1 = require("../../logger");
const parseRuntimeAndValidateSDK_1 = require("./parseRuntimeAndValidateSDK");
const functionsDeployHelper_1 = require("./functionsDeployHelper");
const backend = require("./backend");
const fsutils = require("../../fsutils");
const projectPath = require("../../projectPath");
const cjson = require("cjson");
function functionsDirectoryExists(options, sourceDirName) {
    if (!fsutils.dirExistsSync(projectPath.resolveProjectPath(options, sourceDirName))) {
        const msg = `could not deploy functions because the ${clc.bold('"' + sourceDirName + '"')} ` +
            `directory was not found. Please create it or specify a different source directory in firebase.json`;
        throw new error_1.FirebaseError(msg);
    }
}
exports.functionsDirectoryExists = functionsDirectoryExists;
function functionIdsAreValid(functions) {
    const validFunctionNameRegex = /^[a-zA-Z0-9_-]{1,62}$/;
    const invalidIds = functions.filter((fn) => !validFunctionNameRegex.test(fn.id));
    if (invalidIds.length !== 0) {
        const msg = `${invalidIds.join(", ")} function name(s) can only contain letters, ` +
            `numbers, hyphens, and not exceed 62 characters in length`;
        throw new error_1.FirebaseError(msg);
    }
}
exports.functionIdsAreValid = functionIdsAreValid;
function packageJsonIsValid(sourceDirName, sourceDir, projectDir, hasRuntimeConfigInConfig) {
    const packageJsonFile = path.join(sourceDir, "package.json");
    if (!fsutils.fileExistsSync(packageJsonFile)) {
        const msg = `No npm package found in functions source directory. Please run 'npm init' inside ${sourceDirName}`;
        throw new error_1.FirebaseError(msg);
    }
    let data;
    try {
        data = cjson.load(packageJsonFile);
        logger_1.logger.debug("> [functions] package.json contents:", JSON.stringify(data, null, 2));
        assertFunctionsSourcePresent(data, sourceDir, projectDir);
    }
    catch (e) {
        const msg = `There was an error reading ${sourceDirName}${path.sep}package.json:\n\n ${e.message}`;
        throw new error_1.FirebaseError(msg);
    }
    if (!hasRuntimeConfigInConfig) {
        assertEnginesFieldPresent(data);
    }
}
exports.packageJsonIsValid = packageJsonIsValid;
function checkForInvalidChangeOfTrigger(fn, exFn) {
    const wantEventTrigger = backend.isEventTrigger(fn.trigger);
    const haveEventTrigger = backend.isEventTrigger(exFn.trigger);
    if (!wantEventTrigger && haveEventTrigger) {
        throw new error_1.FirebaseError(`[${functionsDeployHelper_1.getFunctionLabel(fn)}] Changing from a background triggered function to an HTTPS function is not allowed. Please delete your function and create a new one instead.`);
    }
    if (wantEventTrigger && !haveEventTrigger) {
        throw new error_1.FirebaseError(`[${functionsDeployHelper_1.getFunctionLabel(fn)}] Changing from an HTTPS function to an background triggered function is not allowed. Please delete your function and create a new one instead.`);
    }
    if (fn.apiVersion == 2 && exFn.apiVersion == 1) {
        throw new error_1.FirebaseError(`[${functionsDeployHelper_1.getFunctionLabel(fn)}] Upgrading from GCFv1 to GCFv2 is not yet supported. Please delete your old function or wait for this feature to be ready.`);
    }
    if (fn.apiVersion == 1 && exFn.apiVersion == 2) {
        throw new error_1.FirebaseError(`[${functionsDeployHelper_1.getFunctionLabel(fn)}] Functions cannot be downgraded from GCFv2 to GCFv1`);
    }
}
exports.checkForInvalidChangeOfTrigger = checkForInvalidChangeOfTrigger;
function assertFunctionsSourcePresent(data, sourceDir, projectDir) {
    const indexJsFile = path.join(sourceDir, data.main || "index.js");
    if (!fsutils.fileExistsSync(indexJsFile)) {
        const msg = `${path.relative(projectDir, indexJsFile)} does not exist, can't deploy Cloud Functions`;
        throw new error_1.FirebaseError(msg);
    }
}
function assertEnginesFieldPresent(data) {
    if (!data.engines || !data.engines.node) {
        throw new error_1.FirebaseError(parseRuntimeAndValidateSDK_1.RUNTIME_NOT_SET);
    }
}
