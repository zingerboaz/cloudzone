"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepare = void 0;
const clc = require("cli-color");
const utils_1 = require("../../utils");
const parseRuntimeAndValidateSDK_1 = require("./parseRuntimeAndValidateSDK");
const functionsDeployHelper_1 = require("./functionsDeployHelper");
const prompts_1 = require("./prompts");
const prepareFunctionsUpload_1 = require("./prepareFunctionsUpload");
const checkRuntimeDependencies_1 = require("./checkRuntimeDependencies");
const error_1 = require("../../error");
const backend = require("./backend");
const ensureApiEnabled = require("../../ensureApiEnabled");
const functionsConfig = require("../../functionsConfig");
const getProjectId = require("../../getProjectId");
const validate = require("./validate");
async function prepare(context, options, payload) {
    if (!options.config.has("functions")) {
        return;
    }
    const sourceDirName = options.config.get("functions.source");
    if (!sourceDirName) {
        throw new error_1.FirebaseError(`No functions code detected at default location (./functions), and no functions.source defined in firebase.json`);
    }
    const sourceDir = options.config.path(sourceDirName);
    const projectDir = options.config.projectDir;
    const projectId = getProjectId(options);
    const runtimeFromConfig = options.config.get("functions.runtime") || "";
    context.runtimeChoice = parseRuntimeAndValidateSDK_1.getRuntimeChoice(sourceDir, runtimeFromConfig);
    const checkAPIsEnabled = await Promise.all([
        ensureApiEnabled.ensure(projectId, "cloudfunctions.googleapis.com", "functions"),
        ensureApiEnabled.check(projectId, "runtimeconfig.googleapis.com", "runtimeconfig", true),
        checkRuntimeDependencies_1.checkRuntimeDependencies(projectId, context.runtimeChoice),
    ]);
    context.runtimeConfigEnabled = checkAPIsEnabled[1];
    const firebaseConfig = await functionsConfig.getFirebaseConfig(options);
    context.firebaseConfig = firebaseConfig;
    utils_1.logBullet(clc.cyan.bold("functions:") +
        " preparing " +
        clc.bold(options.config.get("functions.source")) +
        " directory for uploading...");
    context.functionsSource = await prepareFunctionsUpload_1.prepareFunctionsUpload(context, options);
    const defaultEnvVariables = {
        FIREBASE_CONFIG: JSON.stringify(context.firebaseConfig),
    };
    const wantBackend = options.config.get("functions.backend");
    wantBackend.cloudFunctions.forEach((fn) => {
        fn.environmentVariables = defaultEnvVariables;
    });
    await Promise.all(Object.keys(wantBackend.requiredAPIs).map((friendlyName) => {
        ensureApiEnabled.ensure(projectId, wantBackend.requiredAPIs[friendlyName], friendlyName, false);
    }));
    payload.functions = {
        backend: wantBackend,
    };
    validate.functionsDirectoryExists(options, sourceDirName);
    validate.functionIdsAreValid(wantBackend.cloudFunctions);
    validate.packageJsonIsValid(sourceDirName, sourceDir, projectDir, !!runtimeFromConfig);
    context.filters = functionsDeployHelper_1.getFilterGroups(options);
    const wantFunctions = wantBackend.cloudFunctions.filter((fn) => {
        return functionsDeployHelper_1.functionMatchesAnyGroup(fn, context.filters);
    });
    const haveFunctions = (await backend.existingBackend(context)).cloudFunctions;
    await prompts_1.promptForFailurePolicies(options, wantFunctions, haveFunctions);
    await prompts_1.promptForMinInstances(options, wantFunctions, haveFunctions);
    await backend.checkAvailability(context, wantBackend);
}
exports.prepare = prepare;
